package org.uma.jmetal.problem.multiobjective.multiobjectiveknapsack;

import java.util.Arrays;
import java.util.BitSet;
import java.util.List;
import java.util.stream.IntStream;
import org.uma.jmetal.problem.binaryproblem.impl.AbstractBinaryProblem;
import org.uma.jmetal.solution.binarysolution.BinarySolution;
import org.uma.jmetal.util.errorchecking.Check;

/**
 * This class represents a multi-objective knapsack problem. The problem involves selecting items to
 * maximize multiple objectives (e.g., profit, importance) while satisfying multiple constraints
 * (e.g., weight, volume).
 *
 * <p>Problem Description: - There are n items, each item j has multiple attributes (e.g., profit,
 * weight). - There are m objectives to maximize. - There are L constraints to satisfy.
 *
 * <p>Inputs: - int[][] profits: An m x n matrix where profits[k][j] represents the profit of item j
 * for objective k. - int[][] weights: An L x n matrix where weights[l][j] represents the weight of
 * item j for constraint l. - int[] capacities: An array of length L representing the capacity for
 * each constraint.
 *
 * <p>Decision Variables: - Binary decision variable x_j indicates whether item j is included in the
 * knapsack (x_j ∈ {0, 1}).
 *
 * <p>Objectives: - Maximize each of the m objectives: max ∑ (p_j^k * x_j) for k = 1, ..., m
 *
 * <p>Constraints: - Each of the L constraints must be satisfied: ∑ (w_j^l * x_j) ≤ c^l for l = 1,
 * ..., L
 *
 * <p>Example: Consider a scenario with 3 items, 2 objectives (profit and importance), and 2
 * constraints (weight and volume): - Items: - Item 1: profit = 10, importance = 8, weight = 2,
 * volume = 3 - Item 2: profit = 5, importance = 4, weight = 3, volume = 2 - Item 3: profit = 15,
 * importance = 10, weight = 5, volume = 4 - Constraints: - Maximum weight = 8 - Maximum volume = 6
 *
 * <p>Example instantiation: int[][] profits = { {10, 5, 15}, {8, 4, 10} }; int[][] weights = { {2,
 * 3, 5}, {3, 2, 4} }; int[] capacities = {8, 6};
 *
 * <p>MultiObjectiveKnapsack problem = new MultiObjectiveKnapsack(profits, weights, capacities);
 *
 * <p>This class extends AbstractBinaryProblem and overrides the evaluate and createSolution
 * methods.
 *
 * <p>(Documentation generated by ChatGPT)
 *
 * @author Antonio J. Nebro
 */
public class MultiObjectiveKnapsack extends AbstractBinaryProblem {
  private final int[][] objectives;
  private final int[][] constraints;
  private final int[] capacities;

  public MultiObjectiveKnapsack(int[][] objectives, int[][] constraints, int[] capacities) {
    Check.that(
        Arrays.stream(objectives).mapToInt(vector -> vector.length).distinct().count() == 1,
        "The objective vectors must have the same size");
    Check.that(
        Arrays.stream(constraints).mapToInt(vector -> vector.length).distinct().count() == 1,
        "The constraint vectors must have the same size");
    Check.that(
        objectives[0].length == constraints[0].length,
        "The number of objectives ("
            + objectives[0].length
            + ") must be equal to the number of constraints ("
            + constraints[0].length
            + ")");

    Check.that(
        Arrays.stream(capacities).allMatch(capacity -> capacity > 0),
        "All the capacities must be greater than zero");

    this.objectives = objectives;
    this.constraints = constraints;
    this.capacities = capacities;
  }

  @Override
  public int numberOfVariables() {
    return 1;
  }

  @Override
  public int numberOfObjectives() {
    return objectives.length;
  }

  @Override
  public int numberOfConstraints() {
    return capacities.length;
  }

  @Override
  public List<Integer> numberOfBitsPerVariable() {
    return List.of(objectives[0].length);
  }

  @Override
  public String name() {
    return "Knapsack";
  }

  public int[] capacities() {
    return capacities;
  }

  public int[][] constraints() {
    return constraints;
  }

  public int[][] objectives() {
    return objectives;
  }

  @Override
  public BinarySolution evaluate(BinarySolution solution) {
    int[] totalProfits = new int[objectives.length];
    int[] totalWeights = new int[constraints.length];

    BitSet bitSet = solution.variables().get(0);

    for (int i = 0; i < bitSet.length(); i++) {
      if (bitSet.get(i)) {
        for (int j = 0; j < objectives.length; j++) {
          totalProfits[j] += objectives[j][i];
        }
        for (int j = 0; j < constraints.length; j++) {
          totalWeights[j] += constraints[j][i];
        }
      }
    }

    IntStream.range(0, capacities.length)
        .forEach(
            i -> {
              if (totalWeights[i] > capacities[i]) {
                solution.constraints()[i] = 1.0 * capacities[i] - totalWeights[i];
              }
            });

    IntStream.range(0, numberOfObjectives())
        .forEach(i -> solution.objectives()[i] = -totalProfits[i]);
    return solution;
  }
}
