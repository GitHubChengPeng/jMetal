package org.uma.jmetal.problem.multiobjective.multiobjectiveknapsack;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.BitSet;
import java.util.List;
import java.util.stream.IntStream;
import org.uma.jmetal.problem.binaryproblem.impl.AbstractBinaryProblem;
import org.uma.jmetal.solution.binarysolution.BinarySolution;
import org.uma.jmetal.util.errorchecking.Check;

/**
 * This class represents a multi-objective knapsack problem. The problem involves selecting items to
 * maximize multiple objectives (e.g., profit, importance) while satisfying multiple constraints
 * (e.g., weight, volume).
 *
 * <p>Problem Description: - There are n items, each item j has multiple attributes (e.g., profit,
 * weight). - There are m objectives to maximize. - There are L constraints to satisfy.
 *
 * <p>Inputs: - int[][] objectives: An m x n matrix where objectives[k][j] represents the profit of item j
 * for objective k. - int[][] constraints: An L x n matrix where constraints[l][j] represents the weight of
 * item j for constraint l. - int[] capacities: An array of length L representing the capacity for
 * each constraint.
 *
 * <p>Decision Variables: - Binary decision variable x_j indicates whether item j is included in the
 * knapsack (x_j ∈ {0, 1}).
 *
 * <p>Objectives: - Maximize each of the m objectives: max ∑ (p_j^k * x_j) for k = 1, ..., m
 *
 * <p>Constraints: - Each of the L constraints must be satisfied: ∑ (w_j^l * x_j) ≤ c^l for l = 1,
 * ..., L
 *
 * <p>Example: Consider a scenario with 3 items, 2 objectives (profit and importance), and 2
 * constraints (weight and volume): - Items: - Item 1: profit = 10, importance = 8, weight = 2,
 * volume = 3 - Item 2: profit = 5, importance = 4, weight = 3, volume = 2 - Item 3: profit = 15,
 * importance = 10, weight = 5, volume = 4 - Constraints: - Maximum weight = 8 - Maximum volume = 6
 *
 * <p>Example instantiation: int[][] profits = { {10, 5, 15}, {8, 4, 10} }; int[][] weights = { {2,
 * 3, 5}, {3, 2, 4} }; int[] capacities = {8, 6};
 *
 * <p>MultiObjectiveKnapsack problem = new MultiObjectiveKnapsack(profits, weights, capacities);
 *
 * <p>This class extends AbstractBinaryProblem and overrides the evaluate and createSolution
 * methods.
 *
 * <p>(Documentation generated by ChatGPT)
 *
 * @author Antonio J. Nebro
 */
public class MultiObjectiveKnapsack extends AbstractBinaryProblem {
  private final int[][] objectives;
  private final int[][] constraints;
  private final int[] capacities;

  public MultiObjectiveKnapsack(int[][] objectives, int[][] constraints, int[] capacities) {
    Check.that(
        Arrays.stream(objectives).mapToInt(vector -> vector.length).distinct().count() == 1,
        "The objective vectors must have the same size");
    Check.that(
        Arrays.stream(constraints).mapToInt(vector -> vector.length).distinct().count() == 1,
        "The constraint vectors must have the same size");
    Check.that(
        objectives[0].length == constraints[0].length,
        "The number of objectives ("
            + objectives[0].length
            + ") must be equal to the number of constraints ("
            + constraints[0].length
            + ")");

    Check.that(
        Arrays.stream(capacities).allMatch(capacity -> capacity > 0),
        "All the capacities must be greater than zero");

    this.objectives = objectives;
    this.constraints = constraints;
    this.capacities = capacities;
  }

  @Override
  public int numberOfVariables() {
    return 1;
  }

  @Override
  public int numberOfObjectives() {
    return objectives.length;
  }

  @Override
  public int numberOfConstraints() {
    return capacities.length;
  }

  @Override
  public List<Integer> numberOfBitsPerVariable() {
    return List.of(objectives[0].length);
  }

  @Override
  public String name() {
    return "Knapsack";
  }

  public int[] capacities() {
    return capacities;
  }

  public int[][] constraints() {
    return constraints;
  }

  public int[][] objectives() {
    return objectives;
  }

  @Override
  public BinarySolution evaluate(BinarySolution solution) {
    int[] totalObjectives = new int[objectives.length];
    int[] totalConstraints = new int[constraints.length];

    BitSet bitSet = solution.variables().get(0);

    for (int i = 0; i < bitSet.length(); i++) {
      if (bitSet.get(i)) {
        for (int j = 0; j < objectives.length; j++) {
          totalObjectives[j] += objectives[j][i];
        }
        for (int j = 0; j < constraints.length; j++) {
          totalConstraints[j] += constraints[j][i];
        }
      }
    }

    IntStream.range(0, capacities.length)
        .forEach(
            i -> {
              if (totalConstraints[i] > capacities[i]) {
                solution.constraints()[i] = 1.0 * capacities[i] - totalConstraints[i];
              }
            });

    IntStream.range(0, numberOfObjectives())
        .forEach(i -> solution.objectives()[i] = -totalObjectives[i]);

    return solution;
  }

  private static List<String> readLinesFromFile(String filename) throws IOException {
    List<String> lines = new ArrayList<>();
    try (BufferedReader br = new BufferedReader(new FileReader(filename))) {
      String line;
      while ((line = br.readLine()) != null) {
        line = line.trim();
        if (!line.isEmpty() && !line.startsWith("#")) {
          lines.add(line);
        }
      }
    }
    return lines;
  }

  /**
   * Reads data from a specified file where each objective and constraint value is stored on separate lines.
   *
   * @param filename the path to the data file
   * @return an instance of MKPProblem
   * @throws IOException if an error occurs while reading the file
   */
  public static MultiObjectiveKnapsack readMKP(String filename) throws IOException {
    List<String> lines = readLinesFromFile(filename);
    int numberOfItems = Integer.parseInt(lines.get(0));
    int numberOfObjectives = Integer.parseInt(lines.get(1));
    int numberOfConstraints = Integer.parseInt(lines.get(2));

    int[][] objectives = new int[numberOfObjectives][numberOfItems];
    int[][] constraints = new int[numberOfConstraints][numberOfItems];
    int[] capacities = new int[numberOfConstraints];

    // Read objective values from the file
    int baseObjectiveIndex = 3;
    for (int i = 0; i < numberOfObjectives; i++) {
      for (int j = 0; j < numberOfItems; j++) {
        objectives[i][j] = Integer.parseInt(lines.get(baseObjectiveIndex + i * numberOfItems + j));
      }
    }

    // Read constraint values from the file
    int baseConstraintIndex = baseObjectiveIndex + numberOfObjectives * numberOfItems;
    for (int i = 0; i < numberOfConstraints; i++) {
      for (int j = 0; j < numberOfItems; j++) {
        constraints[i][j] = Integer.parseInt(lines.get(baseConstraintIndex + i * numberOfItems + j));
      }
      capacities[i] = Integer.parseInt(lines.get(baseConstraintIndex + (i + 1) * numberOfItems));
    }

    return new MultiObjectiveKnapsack(objectives, constraints, capacities);
  }

  /**
   * Reads data from a specified file in a compact format where objectives and constraints are stored in a single line.
   *
   * @param filename the path to the data file
   * @return an instance of MKPProblem
   * @throws IOException if an error occurs while reading the file
   */
  public static MultiObjectiveKnapsack readMKPCompact(String filename) throws IOException {
    List<String> lines = readLinesFromFile(filename);
    int numberOfItems = Integer.parseInt(lines.get(0));
    int numberOfObjectives = Integer.parseInt(lines.get(1));
    int numberOfConstraints = Integer.parseInt(lines.get(2));

    int[][] objectives = new int[numberOfObjectives][numberOfItems];
    int[][] constraints = new int[numberOfConstraints][numberOfItems];
    int[] capacities = new int[numberOfConstraints];

    // Read objectives
    for (int i = 0; i < numberOfObjectives; i++) {
      String[] objectiveLine = lines.get(3 + i).split("\\s+");
      for (int j = 0; j < objectiveLine.length; j++) {
        objectives[i][j] = Integer.parseInt(objectiveLine[j]);
      }
    }

    // Read constraints and capacities
    for (int i = 0; i < numberOfConstraints; i++) {
      String[] constraintLine = lines.get(3 + numberOfObjectives + (i * 2)).split("\\s+");
      for (int j = 0; j < numberOfItems; j++) {
        constraints[i][j] = Integer.parseInt(constraintLine[j]);
      }
      capacities[i] = Integer.parseInt(lines.get(3 + numberOfObjectives + (i * 2) + 1));
    }

    return new MultiObjectiveKnapsack(objectives, constraints, capacities);
  }

}
