package org.uma.jmetal.problem.multiobjective.multiobjectiveknapsack;

import org.uma.jmetal.problem.binaryproblem.impl.AbstractBinaryProblem;
import org.uma.jmetal.solution.binarysolution.BinarySolution;
import org.uma.jmetal.util.errorchecking.Check;

import java.util.BitSet;
import java.util.List;
import java.util.stream.IntStream;

/**
 * This class represents a multi-objective knapsack problem.
 * The problem involves selecting items to maximize multiple objectives
 * (e.g., profit, importance) while satisfying multiple constraints
 * (e.g., weight, volume).
 *
 * Problem Description:
 * - There are n items, each item j has multiple attributes (e.g., profit, weight).
 * - There are m objectives to maximize.
 * - There are L constraints to satisfy.
 *
 * Inputs:
 * - int[][] profits: An m x n matrix where profits[k][j] represents the profit of item j for objective k.
 * - int[][] weights: An L x n matrix where weights[l][j] represents the weight of item j for constraint l.
 * - int[] capacities: An array of length L representing the capacity for each constraint.
 *
 * Decision Variables:
 * - Binary decision variable x_j indicates whether item j is included in the knapsack (x_j ∈ {0, 1}).
 *
 * Objectives:
 * - Maximize each of the m objectives:
 *   max ∑ (p_j^k * x_j) for k = 1, ..., m
 *
 * Constraints:
 * - Each of the L constraints must be satisfied:
 *   ∑ (w_j^l * x_j) ≤ c^l for l = 1, ..., L
 *
 * Example:
 * Consider a scenario with 3 items, 2 objectives (profit and importance), and 2 constraints (weight and volume):
 * - Items:
 *   - Item 1: profit = 10, importance = 8, weight = 2, volume = 3
 *   - Item 2: profit = 5, importance = 4, weight = 3, volume = 2
 *   - Item 3: profit = 15, importance = 10, weight = 5, volume = 4
 * - Constraints:
 *   - Maximum weight = 8
 *   - Maximum volume = 6
 *
 * Usage:
 * This class can be used with a multi-objective optimization algorithm in JMetal,
 * such as NSGA-II or SPEA2, to solve the defined multi-objective knapsack problem.
 *
 * Example instantiation:
 * int[][] profits = {
 *     {10, 5, 15},
 *     {8, 4, 10}
 * };
 * int[][] weights = {
 *     {2, 3, 5},
 *     {3, 2, 4}
 * };
 * int[] capacities = {8, 6};
 *
 * MultiObjectiveKnapsack problem = new MultiObjectiveKnapsack(profits, weights, capacities);
 *
 * This class extends AbstractBinaryProblem and overrides the evaluate and createSolution methods.
 *
 * (Documentation generated by ChatGPT)
 *
 * @author Antonio J. Nebro
 */
public class MultiObjectiveKnapsackOld extends AbstractBinaryProblem {
  private final List<int[]> profits;
  private final int[] weights;
  private final int capacity;

  public MultiObjectiveKnapsackOld(List<int[]> profits, int[] weights, int capacity) {
    Check.that(
        profits.stream().mapToInt(arr -> arr.length).distinct().count() == 1,
        "The profit vectors must have the same size");
    Check.that(
        profits.get(0).length == weights.length,
        "The number of profits ("
            + profits.get(0).length
            + ") must be equal to the number of weights ("
            + weights.length
            + ")");
    Check.that(capacity > 0, "The capacity (" + capacity + ") must be greater than zero");

    this.profits = profits;
    this.weights = weights;
    this.capacity = capacity;
  }

  @Override
  public int numberOfVariables() {
    return 1;
  }

  @Override
  public int numberOfObjectives() {
    return profits.size();
  }

  @Override
  public int numberOfConstraints() {
    return 1;
  }

  @Override
  public List<Integer> numberOfBitsPerVariable() {
    return List.of(weights.length);
  }

  @Override
  public String name() {
    return "Knapsack";
  }

  public int capacity() {
    return capacity;
  }

  public int[] weights() {
    return weights;
  }

  public List<int[]> profits() {
    return profits;
  }

  @Override
  public BinarySolution evaluate(BinarySolution solution) {
    int[] totalProfits = new int[profits.size()];
    int totalWeight = 0;

    BitSet bitSet = solution.variables().get(0);

    for (int i = 0; i < bitSet.length(); i++) {
      if (bitSet.get(i)) {
        totalWeight += weights[i];
        for (int j = 0; j < profits.size(); j++) {
          totalProfits[j] += profits.get(j)[i];
        }
      }
    }

    if (totalWeight > capacity) {
      solution.constraints()[0] = 1.0 * capacity - totalWeight;
    }

    IntStream.range(0, numberOfObjectives()).forEach(i -> solution.objectives()[i] = -totalProfits[i]);
    return solution;
  }
}
